import Foundation

struct Immediate {
    let name: String?
    let type: String
}
struct Instruction {
    let name: String
    let immediates: [Immediate]

 
    /// Parse as follows:
    ///
    /// "`if`(then: Expression, else: Expression, type: ResultType)"
    ///    -> Instruction(name: "`if`", immediates: [
    ///         Immediate(name: "then", type: "Expression"),
    ///         Immediate(name: "else", type: "Expression"),
    ///         Immediate(name: "type", type: "ResultType"),
    ///       ])
    /// "`return`"
    ///    -> Instruction(name: "return", immediates: [])
    /// "memoryInit(DataIndex)"
    ///    -> Instruction(name: "memoryInit", immediates: [
    ///         Immediate(name: nil, type: "DataIndex")
    ///       ])
    static func parse(line: String) -> Instruction {
        var cursor = line.startIndex
        var head: Character { line[cursor] }
        func advance(_ n: Int = 1) {
            cursor = line.index(after: cursor)
        }
        func skipWhitespace() {
            while cursor < line.endIndex && head.isWhitespace {
                advance()
            }
        }
        func eatChar(_ ch: Character) {
            assert(head == ch)
            advance()
        }
        func eatIdentifier() -> String {
            var identifier = ""
            while cursor < line.endIndex && (head.isLetter || head.isHexDigit || head == "`" || head == ".") {
                identifier.append(head)
                advance()
            }
            return identifier
        }
        func eatType() -> String {
            if head == "[" {
                var id = "["
                eatChar("[")
                id += eatType()
                eatChar("]")
                id += "]"
                return id
            }
            return eatIdentifier()
        }

        let name = eatIdentifier()
        guard cursor < line.endIndex, head == "(" else {
            return Instruction(name: name, immediates: [])
        }
        eatChar("(")
        var immediates: [Immediate] = []
        while head != ")" {
            let immediateName: String?
            let immediateType: String
            let firstId = eatIdentifier()
            skipWhitespace()
            if head == ":" {
                eatChar(":")
                immediateName = firstId
                skipWhitespace()
                immediateType = eatType()
            } else {
                immediateName = nil
                immediateType = firstId
            }
            skipWhitespace()
            if head == "=" {
                eatChar("=")
                skipWhitespace()
                _ = eatIdentifier()
            }
            immediates.append(Immediate(name: immediateName, type: immediateType))
            if head == "," {
                advance()
            }
            skipWhitespace()
        }
        eatChar(")")
        return Instruction(name: name, immediates: immediates)
    }
}

func camelCase(pascalCase: String) -> String {
    let first = pascalCase.first!.lowercased()
    return first + pascalCase.dropFirst()
}

func generateDispatcher(instructions: [Instruction]) {
    var output = """
    // This file is generated by Utilities/generate_inst_dispatch.swift
    // swiftlint:disable all
    import Foundation

    extension ExecutionState {
        mutating func doExecute(_ instruction: Instruction, runtime: Runtime) throws {
            switch instruction {
    """

    let controlInsts = [
        "unreachable", "nop", "block", "loop", "`if`", "br", "brIf", "brTable", "`return`", "call", "callIndirect"
    ]

    for inst in instructions {
        if inst.immediates.isEmpty {
            output += """

                    case .\(inst.name):
                        try self.\(inst.name)(runtime: runtime)
            """
        } else {
            let labels = inst.immediates.map {
                $0.name ?? camelCase(pascalCase: String($0.type.split(separator: ".").last!))
            }
            output += """

                    case .\(inst.name)(\(labels.map { "let \($0)" }.joined(separator: ", "))):
                        try self.\(inst.name)(runtime: runtime, \(labels.map { "\($0): \($0)" }.joined(separator: ", ")))
            """
        }
        if controlInsts.contains(inst.name) {
            output += """

                        return
            """
        }
    }
    output += """

            }
            programCounter += 1
        }
    }
    """
    print(output)
}

func generatePrototype(instructions: [Instruction]) {
    var output = """
    // This file is generated by Utilities/generate_inst_dispatch.swift
    // swiftlint:disable all
    import Foundation

    extension ExecutionState {
    """
    for inst in instructions {
        if inst.immediates.isEmpty {
            output += """

            mutating func \(inst.name)(runtime: Runtime) throws {
                fatalError("Unimplemented instruction: \(inst.name)")
            }
        """
        } else {
            let labelTypes = inst.immediates.map {
                let label = $0.name ?? camelCase(pascalCase: String($0.type.split(separator: ".").last!))
                return (label, $0.type)
            }
            output += """

            mutating func \(inst.name)(runtime: Runtime, \(labelTypes.map { "\($0): \($1)" }.joined(separator: ", "))) throws {
                fatalError("Unimplemented instruction: \(inst.name)")
            }
        """
        }
    }
    output += """

    }
    """
    print(output)
}

func generateInstName(instructions: [Instruction]) {
    var output = """
    extension Instruction {
        var name: String {
            switch self {
    """
    for inst in instructions {
        output += """

            case .\(inst.name):
                return "\(inst.name)"
        """
    }
    output += """

            }
        }
    }
    """
    print(output)
}

func main(arguments: [String]) throws {
    let sourceRoot = URL(fileURLWithPath: #filePath).deletingLastPathComponent().deletingLastPathComponent()
    let inputFile = sourceRoot.appending(path: "Sources/WasmKit/Execution/Instructions/Instruction.swift")

    let input = try! String(contentsOf: inputFile)
    let lines = input.components(separatedBy: .newlines)

    let instructions = lines.compactMap { line -> Instruction? in
        guard line.contains("  case ") else { return nil }
        let caseLine = line.split(separator: "  case ", maxSplits: 1)[1]
        return Instruction.parse(line: String(caseLine))
    }

    if arguments.count > 1 {
        switch arguments[1] {
        case "prototype":
            generatePrototype(instructions: instructions)
            return
        case "inst-name":
            generateInstName(instructions: instructions)
            return
        default: break
        }
    }

    generateDispatcher(instructions: instructions)
}

try main(arguments: CommandLine.arguments)
