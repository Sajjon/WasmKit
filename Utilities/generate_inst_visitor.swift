struct Instruction: Decodable {
    let feature: String
    let name: String
    let visitMethodName: String
    let immediates: [Immediate]

    typealias Immediate = [String]

    init(from decoder: Decoder) throws {
        var container = try decoder.unkeyedContainer()
        feature = try container.decode(String.self)
        name = try container.decode(String.self)
        visitMethodName = try container.decode(String.self)
        if container.isAtEnd {
            immediates = []
        } else {
            immediates = try container.decode([Immediate].self)
        }
    }
}

extension Instruction.Immediate {
    var label: String { self[0] }
    var type: String { self[1] }
}

typealias InstructionSet = [Instruction]

func generateVisitorProtocol(_ instructions: InstructionSet) -> String {
    var code = """
    public protocol InstructionVisitor {
        associatedtype Output
    """
    
    for instruction in instructions {
        code += "\n    "
        code += "mutating func \(instruction.visitMethodName)("
        code += instruction.immediates.map { i in
            "\(i.label): \(i.type)"
        }.joined(separator: ", ")
        code += ") throws -> Output"
    }

    code += """

    }
    """

    return code
}

func generateInstructionEnum(_ instructions: InstructionSet) -> String {
    var code = """
    public enum Instruction: Equatable {

    """

    for instruction in instructions {
        code += "    case `\(instruction.name)`"
        if !instruction.immediates.isEmpty {
            code += "(" + instruction.immediates.map {
                "\($0.label): \($0.type)"
            }.joined(separator: ", ") + ")"
        }
        code += "\n"
    }

    code += "}"

    return code
}

func buildInstructionInstanceFromContext(_ instruction: Instruction) -> String {
    var code = ""
    if instruction.immediates.isEmpty {
        code += ".\(instruction.name)"
    } else {
        code += ".\(instruction.name)("
        code += instruction.immediates.map { i in
            "\(i.label): \(i.label)"
        }.joined(separator: ", ")
        code += ")"
    }
    return code
}

func generateInstructionFactory(_ instructions: InstructionSet) -> String {
    var code = """
    struct InstructionFactory: InstructionVisitor {

    """

    for instruction in instructions {
        code += "    func \(instruction.visitMethodName)("
        code += instruction.immediates.map { i in
            "\(i.label): \(i.type)"
        }.joined(separator: ", ")
        code += ") -> Instruction { "
        code += "return " + buildInstructionInstanceFromContext(instruction)
        code += " }\n"
    }

    code += "}"

    return code
}

func generateTracingVisitor(_ instructions: InstructionSet) -> String {
    var code = """
    public struct InstructionTracingVisitor<V: InstructionVisitor>: InstructionVisitor {
        public let trace: (Instruction) -> Void
        public var visitor: V

        public init(trace: @escaping (Instruction) -> Void, visitor: V) {
            self.trace = trace
            self.visitor = visitor
        }

    """

    for instruction in instructions {
        code += "    public mutating func \(instruction.visitMethodName)("
        code += instruction.immediates.map { i in
            "\(i.label): \(i.type)"
        }.joined(separator: ", ")
        code += ") throws -> V.Output {\n"
        code += "       trace("
        code += buildInstructionInstanceFromContext(instruction)
        code += ")\n"
        code += "       return try visitor.\(instruction.visitMethodName)("
        code += instruction.immediates.map { i in
            "\(i.label): \(i.label)"
        }.joined(separator: ", ")
        code += ")\n"
        code += "    }\n"
    }

    code += "}"

    return code
}

import Foundation

func main() throws {
    let sourceRoot = URL(fileURLWithPath: #filePath).deletingLastPathComponent().deletingLastPathComponent()
    let data = try Data(contentsOf: sourceRoot.appending(path: "Utilities/Instructions.json"))
    let instructions = try JSONDecoder().decode(InstructionSet.self, from: data)

    do {
        let outputFile = sourceRoot.appending(path: "Sources/WasmParser/InstructionVisitor.swift")
        var output = """
        // This file is generated by Utilities/generate_inst_visitor.swift

        """
        output += generateInstructionEnum(instructions)
        output += "\n\n"
        output += generateInstructionFactory(instructions)
        output += "\n\n"
        output += generateTracingVisitor(instructions)
        output += "\n\n"
        output += generateVisitorProtocol(instructions)
        output += "\n"
        try output.write(to: outputFile, atomically: true, encoding: .utf8)
    }
}

try main()
